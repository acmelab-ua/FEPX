.. _simulation_output:

Simulation Output
=================

In this section the output files are described. In general, the output can be broken down into five types: nodal output (variables that are calculated and printed at the finite element nodes), elemental output (variables that are calculated and printed at the finite elements), restart output (which contains all variables necessary to restart a simulation at a specific load step), miscellaneous output (macroscopic forces and various simulation statistics), and fiber averaged output (fiber averaged values of certain variables and other statistics associated with the fiber average output option).

All desired output must be defined in the @file{simulation.config} file (@pxref{Printing Results} for a description of the print options). A (small) @file{post.report} file is systematically printed, which contains information necessary for post-processing with Neper. All output described in this section is @emph{raw} simulation output and can be post-processed into a more human-readable format with Neper's @samp{-S} module. Refer to the Neper reference manual, @url{https://neper.info/docs/neper.pdf}, for a more complete description of the @samp{-S} module.

@section Nodal Output

Nodal output prints a single variable per finite element node. Raw output is printed on a per-core basis, and the general file name structure is @file{post.variable.core#}, where @samp{variable} is the variable being printed, and @samp{#} denotes the ID of the core on which the data is being printed. In general, the file structure is:

@inputfilehead
@example
step_number core_start_dof core_end_dof
node n values
node n+1 values
node n+2 values
...
@end example
@inputfilefoot

Here, a header line prints for each deformation step, which details the deformation step number, the initial degree of freedom that prints from that core, and the final degree of freedom that prints from that core. Note that the number of @dfn{nodes} per-core is one third of the number of degrees of freedoms per-core. For each load step, multiple values associated with a variable are printed per line. When multiple values are printed per line, values are space delimited.

Below, the specific nodal values available for printing are explained in detail.

@ftable @code
@item @file{post.coo.core*} : Coordinates

In this file, the coordinates are printed. Each nodal coordinate is described in the orthonormal Cartesian sample basis, and one coordinate is printed per line (3 values per line). The components of the coordinates are printed in the order:

@var{x}, @var{y}, @var{z}

@item @file{post.disp.core*} : Displacements

In this file, the displacements are printed. Each nodal displacement is described in the orthonormal Cartesian sample basis, and one displacement is printed per line (3 values per line). The components of the displacements are printed in the order:

@var{d}@sub{@var{x}}, @var{d}@sub{@var{y}}, @var{d}@sub{@var{z}}

@item @file{post.vel.core*} : Velocities

In this file, the velocities are printed. Each nodal velocity is described in the orthonormal Cartesian sample basis, and one velocity is printed per line (3 values per line). The components of the velocities are printed in the order:

@var{v}@sub{@var{x}}, @var{v}@sub{@var{y}}, @var{v}@sub{@var{z}}

@end ftable

@section Elemental Output

Elemental output prints a single variable per finite element. Raw output is printed on a per-core basis, and the general file name structure is @file{post.variable.core#}, where @samp{variable} is the variable being printed, and @samp{#} denotes the ID of the core on which the data is being printed. In general, the file structure is:

@c typical_start
@example

    step_number core_start_elt core_end_elt
    element n value(s)
    element n+1 value(s)
    element n+2 value(s)
    ...
    step_number core_start_elt core_end_elt
    element n value(s)
    element n+1 value(s)
    element n+2 value(s)
    ...

@end example
@c typical_end

Here, a header line prints for each deformation step, which details the deformation step number, the initial element that prints from that core, and the final element that prints from that core. For each load step, either a single value associated with a variable is printed per line (for variables that are printed singularly per element, such as scalars), or multiple values associated with a variable are printed per line (for variables that print multiple values per element, such as tensors). When multiple values are printed per line, values are space delimited.

FEPX calculates elemental quantities at each Gauss quadrature point within the element (15 total). However, only one value is printed -- that associated with the quadrature point that falls at the element centroid.

@sp 1
Below, the specific nodal values available for printing are explained in detail.

@ftable @asis
@item @file{post.crss.core*} : Critical Resolved Shear Stress

In this file, the critical resolved shear stress is printed. For the isotropic hardening assumption (@pxref{Optional Input Parameters}), one value is printed per element. For anisotropic hardening assumptions, the critical resolved shear stress is printed for each slip system per element, one line of values per element.

For body centered cubic crystal symmetry, values are printed in the order:

@math{ (0 1 \bar 1)[1 1 1],\,(1 0 \bar 1)[1 1 1],\,(1 \bar 1 0)[1 1 1],\,(0 1 1)[1 1 \bar 1],\,(1 0 1)[1 1 \bar 1],\,(1 \bar 1 0)[1 1 \bar 1],}
@math{ (0 1 1)[1 \bar 1 1],\,(1 0 \bar 1)[1 \bar 1 1],\,(1 1 0)[1 \bar 1 1],\,(0 1 \bar 1)[1 \bar 1 \bar 1],\,(1 0 1)[1 \bar 1 \bar 1],\,(1 1 0)[1 \bar 1 \bar 1] }.

For face centered cubic crystal symmetry, values are printed in the order:

@math{ (1 1 1)[0 1 \bar 1],\,(1 1 1)[1 0 \bar 1],\,(1 1 1)[1 \bar 1 0],\,(1 1 \bar 1)[0 1 1],\,(1 1 \bar 1)[1 0 1],\,(1 1 \bar 1)[1 \bar 1 0],\,}
@math{ (1 \bar 1 1)[0 1 1],\,(1 \bar 1 1)[1 0 \bar 1],\,(1 \bar 1 1)[1 1 0],\,(1 \bar 1 \bar 1)[0 1 \bar 1],\,(1 \bar 1 \bar 1)[1 0 1],\,(1 \bar 1 \bar 1)[1 1 0] }.

For hexagonal close packed crystal symmetry, values are printed in the order (corresponding to the 3 basal, 3 prismatic, and 12 pyramidal slip systems):

@math{ (0 0 0 1)[2 \bar 1 \bar 1 0],\,(0 0 0 1)[\bar 1 2 \bar 1 0],\,(0 0 0 1)[\bar 1 \bar 1 2 0],\,(0 1 \bar 1 0)[2 \bar 1 \bar 1 0],\,(\bar 1 0 1 0)[\bar 1 2 \bar 1 0],\,(1 \bar 1 0 0)[\bar 1 \bar 1 2 0],\,}
@math{ (1 0 \bar 1 1)[\bar 2 1 1 3],\,(1 0 \bar 1 1)[\bar 1 \bar 1 2 3],\,(0 1 \bar 1 1)[\bar 1 \bar 1 2 3],\,(0 1 \bar 1 1)[1 \bar 2 1 3],\,(\bar 1 1 0 1)[1 \bar 2 1 3],\,(\bar 1 1 0 1)[2 \bar 1 \bar 1 3],\,}
@math{ (\bar 1 0 1 1)[2 \bar 1 \bar 1 3],\,(\bar 1 0 1 1)[1 1 \bar 2 3],\,(0 \bar 1 1 1)[1 1 \bar 2 3],\,(0 \bar 1 1 1)[\bar 1 2 \bar 1 3],\,(1 \bar 1 0 1)[\bar 1 2 \bar 1 3],\,(1 \bar 1 0 1)[\bar 2 1 1 3] }.

For body centered tetragonal crystal symmetry, values are printed in the order:

@math{(1 0 0)[0 0 1],\,(0 1 0)[0 0 1],\,(1 1 0)[0 0 1],\,(1 \bar 1 0)[0 0 1],\,(1 0 0)[0 1 0],\,(0 1 0)[1 0 0]}
@math{(1 1 0)[1 \bar 1 1],\,(1 1 0)[\bar 1 1 1],\,(1 \bar 1 0)[1 1 1],\,(1 \bar 1 0)[\bar 1 \bar 1 1],\,(1 1 0)[\bar 1 1 0],\,(1 \bar 1 0)[1 1 0]}
@math{(1 0 0)[0 1 1],\,(1 0 0)[0 1 \bar 1],\,(0 1 0)[1 0 1],\,(0 1 0)[1 0 \bar 1],\,(0 0 1)[1 1 0],\,(0 0 1)[1 \bar 1 0]}
@math{(0 0 1)[1 1 0],\,(0 0 1)[1 \bar 1 0],\,(1 0 1)[1 0 \bar 1],\,(1 0 \bar 1)[1 0 1],\,(0 1 1)[0 1 \bar 1],\,(0 1 \bar 1)[0 1 1]}
@math{(1 2 1)[\bar 1 0 1],\,(\bar 1 2 1)[1 0 1],\,(\bar 1 \bar 2 1)[1 0 1],\,(1 \bar 2 1)[\bar 1 0 1],\,(2 1 1)[0 \bar 1 1],\,(\bar 2 1 1)[0 \bar 1 1]}
@math{(\bar 2 \bar 1 1)[0 1 1],\,(2 \bar 1 1)[0 1 1]}


@item @file{post.defrate.core*} : Deformation Rate Tensor

In this file, the deformation rate tensor is printed. Each tensor, @math{\bf D}, is printed in the sample basis. The independent components are printed, one tensor per line (6 values per line). The components, @math{D _{ij}}, are printed in the order:

@math{D_{11},\,D_{22},\,D_{33},\,D_{23},\,D_{13},\,D_{12}}


@item @file{post.defrate-eq.core*} : Equivalent Deformation Rate

In this file, the equivalent deformation rate is printed. One scalar value is printed per element. The equivalent deformation rate, @math{D}, is calculated based on the deformation rate tensor, @math{{\bf D}}, via the tensor inner product:

@math{D = \sqrt{ {2 \over 3} {\bf D} : {\bf D} }}


@item @file{post.defrate-pl.core*} : Plastic Deformation Rate Tensor

In this file, the deviatoric plastic deformation rate tensor is printed. Each tensor, @math{{\bf D}^p}, is printed in the sample basis. The independent components are printed, one tensor per line (6 values per line). The components, @math{D^p_{ij}}, are printed in the order:

@math{D^p_{11},\,D^p_{22},\,D^p_{33},\,D^p_{23},\,D^p_{13},\,D^p_{12}}


@item @file{post.defrate-pl-eq.core*} : Equivalent Plastic Deformation Rate

In this file, the equivalent plastic deformation rate is printed. One scalar value is printed per element. The equivalent plastic deformation rate, @math{D^p}, is calculated based on the plastic deformation rate tensor, @math{{\bf D}^p}, via the tensor inner product:

@math{D^p = \sqrt{ {2 \over 3} {\bf D}^p : {\bf D}^p }}


@item @file{post.elt-vol.core*} : Elemental Volume

In this file, the elemental volume is printed. One scalar value is printed per element. The elemental volume is calculated as the Gaussian integration of the determinant of the Jacobian matrix:

@math{V_{el} = \sum_{i=1}^{n_{qp}}{det(J_i) w_i }}


@item @file{post.ori.core*} : Crystallographic Orientation

In this file, the crystallographic orientation is printed. Depending on the orientation parameterization used as input, the orientation values may range from 3 values per element (when using Rodrigues vector, Euler-Bunge angles and Euler-Kocks angles parameterizations) or 4 values per element (when using axis-angle or quaternion parameterizations). One orientation is printed per line (3 or 4 values per line).

For Rodrigues: @math{r_1,\,r_2,\,r_3}, where the Rodrigues vector is @math{{\bf r} = {\bf t} \tan{(\omega / 2)}}.

For Euler-Bunge: @math{\phi_1,\,\theta,\,\phi_2} (where @math{\phi_1} is the rotation about the @math{z} axis, @math{\theta} is the rotation about the @math{x^{\prime}} axis, and @math{\phi_2} is the rotation about the @math{z^{\prime \prime}} axis, all in degrees).

For Euler-Kocks: @math{\Psi,\,\Theta,\,\phi} (where @math{\Psi} is the rotation about the @math{z} axis, @math{\Theta} is the rotation about the @math{y^{\prime}} axis, and @math{\phi} is the rotation about the @math{z^{\prime \prime}} axis, all in degrees).

For axis-angle: @math{t_1,\,t_2,\,t_3,\,\omega} (where @math{\bf{t}} is the normalized axis of rotation and @math{\omega} is the angle of rotation about said axis, in degrees).

For quaternion: @math{q_0,\,q_1,\,q_2,\,q_3}, where @math{q_0 = \cos{(\omega / 2)}} and @math{q_i = t_i \sin{(\omega / 2)}} for @math{i = 1,\,2,\,3}.


@item @file{post.slip.core*} : Slip System Shear

In this file, the accumulated slip system shear is printed. The slip system shear is printed for each slip system per element, one line of values per element.

For body centered cubic crystal symmetry, values are printed in the order:

@math{ (0 1 \bar 1)[1 1 1],\,(1 0 \bar 1)[1 1 1],\,(1 \bar 1 0)[1 1 1],\,(0 1 1)[1 1 \bar 1],\,(1 0 1)[1 1 \bar 1],\,(1 \bar 1 0)[1 1 \bar 1],}
@math{ (0 1 1)[1 \bar 1 1],\,(1 0 \bar 1)[1 \bar 1 1],\,(1 1 0)[1 \bar 1 1],\,(0 1 \bar 1)[1 \bar 1 \bar 1],\,(1 0 1)[1 \bar 1 \bar 1],\,(1 1 0)[1 \bar 1 \bar 1] }.

For face centered cubic crystal symmetry, values are printed in the order:

@math{ (1 1 1)[0 1 \bar 1],\,(1 1 1)[1 0 \bar 1],\,(1 1 1)[1 \bar 1 0],\,(1 1 \bar 1)[0 1 1],\,(1 1 \bar 1)[1 0 1],\,(1 1 \bar 1)[1 \bar 1 0],\,}
@math{ (1 \bar 1 1)[0 1 1],\,(1 \bar 1 1)[1 0 \bar 1],\,(1 \bar 1 1)[1 1 0],\,(1 \bar 1 \bar 1)[0 1 \bar 1],\,(1 \bar 1 \bar 1)[1 0 1],\,(1 \bar 1 \bar 1)[1 1 0] }.

For hexagonal close packed crystal symmetry, values are printed in the order (corresponding to the 3 basal, 3 prismatic, and 12 pyramidal slip systems):

@math{ (0 0 0 1)[2 \bar 1 \bar 1 0],\,(0 0 0 1)[\bar 1 2 \bar 1 0],\,(0 0 0 1)[\bar 1 \bar 1 2 0],\,(0 1 \bar 1 0)[2 \bar 1 \bar 1 0],\,(\bar 1 0 1 0)[\bar 1 2 \bar 1 0],\,(1 \bar 1 0 0)[\bar 1 \bar 1 2 0],\,}
@math{ (1 0 \bar 1 1)[\bar 2 1 1 3],\,(1 0 \bar 1 1)[\bar 1 \bar 1 2 3],\,(0 1 \bar 1 1)[\bar 1 \bar 1 2 3],\,(0 1 \bar 1 1)[1 \bar 2 1 3],\,(\bar 1 1 0 1)[1 \bar 2 1 3],\,(\bar 1 1 0 1)[2 \bar 1 \bar 1 3],\,}
@math{ (\bar 1 0 1 1)[2 \bar 1 \bar 1 3],\,(\bar 1 0 1 1)[1 1 \bar 2 3],\,(0 \bar 1 1 1)[1 1 \bar 2 3],\,(0 \bar 1 1 1)[\bar 1 2 \bar 1 3],\,(1 \bar 1 0 1)[\bar 1 2 \bar 1 3],\,(1 \bar 1 0 1)[\bar 2 1 1 3] }.

For body centered tetragonal crystal symmetry, values are printed in the order:

@math{(1 0 0)[0 0 1],\,(0 1 0)[0 0 1],\,(1 1 0)[0 0 1],\,(1 \bar 1 0)[0 0 1],\,(1 0 0)[0 1 0],\,(0 1 0)[1 0 0]}
@math{(1 1 0)[1 \bar 1 1],\,(1 1 0)[\bar 1 1 1],\,(1 \bar 1 0)[1 1 1],\,(1 \bar 1 0)[\bar 1 \bar 1 1],\,(1 1 0)[\bar 1 1 0],\,(1 \bar 1 0)[1 1 0]}
@math{(1 0 0)[0 1 1],\,(1 0 0)[0 1 \bar 1],\,(0 1 0)[1 0 1],\,(0 1 0)[1 0 \bar 1],\,(0 0 1)[1 1 0],\,(0 0 1)[1 \bar 1 0]}
@math{(0 0 1)[1 1 0],\,(0 0 1)[1 \bar 1 0],\,(1 0 1)[1 0 \bar 1],\,(1 0 \bar 1)[1 0 1],\,(0 1 1)[0 1 \bar 1],\,(0 1 \bar 1)[0 1 1]}
@math{(1 2 1)[\bar 1 0 1],\,(\bar 1 2 1)[1 0 1],\,(\bar 1 \bar 2 1)[1 0 1],\,(1 \bar 2 1)[\bar 1 0 1],\,(2 1 1)[0 \bar 1 1],\,(\bar 2 1 1)[0 \bar 1 1]}
@math{(\bar 2 \bar 1 1)[0 1 1],\,(2 \bar 1 1)[0 1 1]}


@item @file{post.sliprate.core*} : Slip System Shear Rate

In this file, the slip system shear rate is printed. The slip system shear rate is printed for each slip system per element, one line of values per element.

For body centered cubic crystal symmetry, values are printed in the order:

@math{ (0 1 \bar 1)[1 1 1],\,(1 0 \bar 1)[1 1 1],\,(1 \bar 1 0)[1 1 1],\,(0 1 1)[1 1 \bar 1],\,(1 0 1)[1 1 \bar 1],\,(1 \bar 1 0)[1 1 \bar 1],}
@math{ (0 1 1)[1 \bar 1 1],\,(1 0 \bar 1)[1 \bar 1 1],\,(1 1 0)[1 \bar 1 1],\,(0 1 \bar 1)[1 \bar 1 \bar 1],\,(1 0 1)[1 \bar 1 \bar 1],\,(1 1 0)[1 \bar 1 \bar 1] }.

For face centered cubic crystal symmetry, values are printed in the order:

@math{ (1 1 1)[0 1 \bar 1],\,(1 1 1)[1 0 \bar 1],\,(1 1 1)[1 \bar 1 0],\,(1 1 \bar 1)[0 1 1],\,(1 1 \bar 1)[1 0 1],\,(1 1 \bar 1)[1 \bar 1 0],\,}
@math{ (1 \bar 1 1)[0 1 1],\,(1 \bar 1 1)[1 0 \bar 1],\,(1 \bar 1 1)[1 1 0],\,(1 \bar 1 \bar 1)[0 1 \bar 1],\,(1 \bar 1 \bar 1)[1 0 1],\,(1 \bar 1 \bar 1)[1 1 0] }.

For hexagonal close packed crystal symmetry, values are printed in the order (corresponding to the 3 basal, 3 prismatic, and 12 pyramidal slip systems):

@math{ (0 0 0 1)[2 \bar 1 \bar 1 0],\,(0 0 0 1)[\bar 1 2 \bar 1 0],\,(0 0 0 1)[\bar 1 \bar 1 2 0],\,(0 1 \bar 1 0)[2 \bar 1 \bar 1 0],\,(\bar 1 0 1 0)[\bar 1 2 \bar 1 0],\,(1 \bar 1 0 0)[\bar 1 \bar 1 2 0],\,}
@math{ (1 0 \bar 1 1)[\bar 2 1 1 3],\,(1 0 \bar 1 1)[\bar 1 \bar 1 2 3],\,(0 1 \bar 1 1)[\bar 1 \bar 1 2 3],\,(0 1 \bar 1 1)[1 \bar 2 1 3],\,(\bar 1 1 0 1)[1 \bar 2 1 3],\,(\bar 1 1 0 1)[2 \bar 1 \bar 1 3],\,}
@math{ (\bar 1 0 1 1)[2 \bar 1 \bar 1 3],\,(\bar 1 0 1 1)[1 1 \bar 2 3],\,(0 \bar 1 1 1)[1 1 \bar 2 3],\,(0 \bar 1 1 1)[\bar 1 2 \bar 1 3],\,(1 \bar 1 0 1)[\bar 1 2 \bar 1 3],\,(1 \bar 1 0 1)[\bar 2 1 1 3] }.

For body centered tetragonal crystal symmetry, values are printed in the order:

@math{(1 0 0)[0 0 1],\,(0 1 0)[0 0 1],\,(1 1 0)[0 0 1],\,(1 \bar 1 0)[0 0 1],\,(1 0 0)[0 1 0],\,(0 1 0)[1 0 0]}
@math{(1 1 0)[1 \bar 1 1],\,(1 1 0)[\bar 1 1 1],\,(1 \bar 1 0)[1 1 1],\,(1 \bar 1 0)[\bar 1 \bar 1 1],\,(1 1 0)[\bar 1 1 0],\,(1 \bar 1 0)[1 1 0]}
@math{(1 0 0)[0 1 1],\,(1 0 0)[0 1 \bar 1],\,(0 1 0)[1 0 1],\,(0 1 0)[1 0 \bar 1],\,(0 0 1)[1 1 0],\,(0 0 1)[1 \bar 1 0]}
@math{(0 0 1)[1 1 0],\,(0 0 1)[1 \bar 1 0],\,(1 0 1)[1 0 \bar 1],\,(1 0 \bar 1)[1 0 1],\,(0 1 1)[0 1 \bar 1],\,(0 1 \bar 1)[0 1 1]}
@math{(1 2 1)[\bar 1 0 1],\,(\bar 1 2 1)[1 0 1],\,(\bar 1 \bar 2 1)[1 0 1],\,(1 \bar 2 1)[\bar 1 0 1],\,(2 1 1)[0 \bar 1 1],\,(\bar 2 1 1)[0 \bar 1 1]}
@math{(\bar 2 \bar 1 1)[0 1 1],\,(2 \bar 1 1)[0 1 1]}


@item @file{post.spinrate.core*} : Plastic Spin Rate Tensor

In this file, the skew-symmetric plastic spin rate tensor is printed. Each tensor, @math{{\bf W}^p}, is printed in the sample basis. The independent components are printed, one tensor per line (3 values per line). The components, @math{W^p_{ij}}, are printed in the order:

@math{ W^p_{12},@ W^p_{13},@ W^p_{23} }


@item @file{post.strain.core*} : Total Strain Tensor

In this file, the total strain tensor is printed. Each tensor, @math{\bf E}, is printed in the sample basis. The independent components are printed, one tensor per line (6 values per line). The components, @math{E_{ij}}, are printed in the order:

@math{ E_{11},@ E_{22},@ E_{33},@ E_{23},@ E_{13},@ E_{12}}


@item @file{post.strain-eq.core*} : Equivalent Total Strain

In this file, the equivalent total strain is printed. One scalar value is printed per element. The equivalent total strain, @math{E}, is calculated based on the deviatoric portion of the total strain tensor, @math{{\bf E}^\prime}. via the tensor inner product:

@math{E = \sqrt{ {2 \over 3} {\bf E}^\prime : {\bf E}^\prime}}


@item @file{post.strain-el.core*} : Elastic Strain Tensor

In this file, the elastic strain tensor is printed. Each tensor, @math{\bf {E}^e}, is printed in the sample basis. The independent components are printed, one tensor per line (6 values per line). The components, @math{E^e_{ij}}, are printed in the order:

@math{ E^e_{11},@ E^e_{22},@ E^e_{33},@ E^e_{23},@ E^e_{13},@ E^e_{12}}


@item @file{post.strain-el-eq.core*} : Equivalent Elastic Strain

In this file, the equivalent elastic strain is printed. One scalar value is printed per element. The equivalent elastic strain, @math{E^{e}}, is calculated based on the deviatoric portion of the elastic strain tensor, @math{{\bf E}^{e \prime}}, via the tensor inner product:

@math{E^e = \sqrt{ {2 \over 3} {\bf E}^{e \prime} : {\bf E}^{e \prime}}}


@item @file{post.strain-pl.core*} : Plastic Strain Tensor

In this file, the plastic strain tensor is printed. Each tensor, @math{\bf {E}^p}, is printed in the sample basis. The independent components are printed, one tensor per line (6 values per line). The components, @math{E^p_{ij}}, are printed in the order:

@math{ E^p_{11},@ E^p_{22},@ E^p_{33},@ E^p_{23},@ E^p_{13},@ E^p_{12}}


@item @file{post.strain-pl-eq.core*} : Equivalent Plastic Strain

In this file, the equivalent plastic strain is printed. One scalar value is printed per element. The equivalent plastic strain, @math{E^p}, is calculated based on the plastic strain tensor, @math{{\bf E}^p}, via the tensor inner product:

@math{E^p = \sqrt{ {2 \over 3} {\bf E}^p : {\bf E}^p }}


@item @file{post.stress.core*} : Stress Tensor

In this file, the symmetric stress tensor is printed. Each tensor, @math{\bf \sigma}, is printed in the sample basis. The independent components are printed, one tensor per line (6 values per line). The components, @math{\sigma_{ij}}, are printed in the order:

@math{ \sigma_{11},@ \sigma_{22},@ \sigma_{33},@ \sigma_{23},@ \sigma_{13},@ \sigma_{12}}


@item @file{post.stress-eq.core*} : Equivalent Stress

In this file, the equivalent stress is printed. One scalar value is printed per element. The equivalent stress, @math{\sigma}, is calculated based on the deviatoric portion of the stress tensor, @math{{\bf \sigma}^{\prime}}, via the tensor inner product:

@math{\sigma = \sqrt{ {3 \over 2} {\bf \sigma}^{\prime} : {\bf \sigma}^{\prime}}}


@item @file{post.velgrad.core*} : Velocity Gradient Tensor

In this file, the velocity gradient tensor is printed. Each tensor, @math{\bf L}, is printed in the sample basis. One tensor is printed per line (9 values per line). The components, @math{L_{ij}},  are printed in the order:

@math{ L_{11},@ L_{12},@ L_{13},@ L_{21},@ L_{22},@ L_{23},@ L_{31},@ L_{32},@ L_{33} }


@item @file{post.work.core*} : Work

In this file, the work is printed. One scalar value is printed per element. The work is calculated as the time integration of the tensor inner product of the deformation rate tensor and the Cauchy stress tensor:

@math{W = \int{  (\sigma : {\bf D}) }\Delta t}


@item @file{post.work-pl.core*} : Plastic Work

In this file, the plastic work is printed. One scalar value is printed per element. The plastic work is calculated as the time integration of the tensor inner product of the plastic deformation rate tensor and the deviatoric portion of the Cauchy stress tensor:

@math{ W^p = \int{ ( \sigma ^ \prime :  {\bf D }^ p ) \Delta t} }

@item @file{post.workrate.core*} : Work Rate

In this file, the work rate is printed. One scalar value is printed per element. The work rate is calculated as the tensor inner product of the deformation rate tensor and the Cauchy stress tensor:

@math{\dot{W} = \sigma : {\bf D} }


@item @file{post.workrate-pl.core*} : Plastic Work Rate

In this file, the plastic work rate is printed. One scalar value is printed per element. The plastic work rate is calculated as the tensor inner product of the plastic deformation rate tensor and the deviatoric portion of the Cauchy stress tensor:

@math{\dot{W}^p = \sigma ^ \prime : {\bf D }^ p }

@end ftable

@node Restart Output
@section Restart Output

If the @samp{@option{print restart}} command is present in the
@file{simulation.config} file, a set of additional restart files will be
generated from the simulation. These files are written at the end of each
prescribed step and contain necessary information to restart a given simulation
(@pxref{Restarting a Simulation} for information on how to restart a
simulation). Two types of restart files are generated, a control file,
@samp{rst@var{N}.control}, and per-core field files,
@samp{rst@var{N}.field.core*} (where @samp{@var{N}} indicates which
simulation the files describe, 0 indexing). Both file types are unformatted
(or binary) files and are generally unmodifiable. The structures of the data
stored within both files for the various deformation modes follow.

@subsection Uniaxial Restart Control

The @file{rst@var{N}.control} file for uniaxial loading modes contains
the following data in the given order:

@inputfilehead
@example
@option{current_step} @var{integer}
@option{previous_load_array} @var{real_x} @var{real_y} @var{real_z}
@option{step_complete_flag} @var{logical}
@option{previous_timestep_value} @var{real}
@option{current_incr} @var{integer}
@option{current_time} @var{real}
@option{surface_1_loads} @var{real_x} @var{real_y} @var{real_z}
...
@option{surface_6_loads} @var{real_x} @var{real_y} @var{real_z}
@option{previous_prescribed_load} @var{real}
@option{current_surface_areas} @var{real_surf_1} ... @var{real_surf_6}
@option{initial_surface_areas} @var{real_surf_1} ... @var{real_surf_6}
@end example
@inputfilefoot

@subsection Multiaxial CSR Restart Control

The @file{rst@var{N}.control} file for multiaxial constant strain rate
loading modes contains the following data in the given order:

@inputfilehead
@example
@option{current_step} @var{integer}
@option{current_load_array} @var{real_x} @var{real_y} @var{real_z}
@option{previous_load_array} @var{real_x} @var{real_y} @var{real_z}
@option{step_complete_flag} @var{logical}
@option{previous_timestep_value} @var{real}
@option{current_incr} @var{integer}
@option{current_time} @var{real}
@option{surface_1_loads} @var{real_x} @var{real_y} @var{real_z}
...
@option{surface_6_loads} @var{real_x} @var{real_y} @var{real_z}
@option{current_surface_areas} @var{real_surf_1} ... @var{real_surf_6}
@option{initial_surface_areas} @var{real_surf_1} ... @var{real_surf_6}
@option{current_mesh_lengths} @var{real_length_x} @var{real_length_y} @var{real_length_z}
@option{initial_mesh_lengths} @var{real_length_x} @var{real_length_y} @var{real_length_z}
@option{current_control_velocity} @var{real_vel_x} @var{real_vel_y} @var{real_vel_z}
@option{s_pert_mag} @var{real}
@option{t_pert_mag} @var{real}
@end example
@inputfilefoot

@subsection Multiaxial CLR Restart Control

The @file{rst@var{N}.control} file for multiaxial constant load rate
loading modes contains the following data in the given order:

@inputfilehead
@example
@option{current_step} @var{integer}
@option{current_load_array} @var{real_x} @var{real_y} @var{real_z}
@option{previous_load_array} @var{real_x} @var{real_y} @var{real_z}
@option{first_incr_in_step} @var{logical}
@option{current_incr} @var{integer}
@option{current_time} @var{real}
@option{surface_1_loads} @var{real_x} @var{real_y} @var{real_z}
...
@option{surface_6_loads} @var{real_x} @var{real_y} @var{real_z}
@option{current_surface_areas} @var{real_surf_1} ... @var{real_surf_6}
@option{initial_surface_areas} @var{real_surf_1} ... @var{real_surf_6}
@option{current_mesh_lengths} @var{real_length_x} @var{real_length_y} @var{real_length_z}
@option{initial_mesh_lengths} @var{real_length_x} @var{real_length_y} @var{real_length_z}
@option{current_control_velocity} @var{real_vel_x} @var{real_vel_y} @var{real_vel_z}
@option{previous_control_action} @var{integer}
@option{current_control_action} @var{integer}
@option{initial_load_dwell_velocity} @var{real_vel_x} @var{real_vel_y} @var{real_vel_z}
@option{initial_unload_dwell_velocity} @var{real_vel_x} @var{real_vel_y} @var{real_vel_z}
@end example
@inputfilefoot

@subsection Restart Field Data

All loading modes also write field data on a per-core basis to
@file{rst@var{N}.field.core*} files. These files contain the necessary
field variable information in order to spatially define the total state of the
virtual sample at the time of printing. The following field data arrays are
written to the files in the given order:

@inputfilehead
@example
@option{coords} @var{real}
@option{velocity} @var{real}

@option{c0_angs} @var{real}
@option{c_angs} @var{real}
@option{rstar} @var{real}
@option{rstar_n} @var{real}
@option{wts} @var{real}
@option{crss} @var{real}
@option{crss_n} @var{real}

@option{gela_kk_bar} @var{real}
@option{gsig_vec_n} @var{real}
@option{pela_kk_bar} @var{real}
@option{psig_vec_n} @var{real}
@option{e_elas_kk_bar} @var{real}
@option{sig_vec_n} @var{real}

@option{eqstrain} @var{real}
@option{eqplstrain} @var{real}
@option{gamma} @var{real}

@option{el_work_n} @var{real}
@option{el_workp_n} @var{real}
@option{el_work_rate_n} @var{real}
@option{el_workp_rate_n} @var{real}
@end example
@inputfilefoot

@node Miscellaneous Output
@section Miscellaneous Output

In addition to nodal and elemental variable printing, miscellaneous output is available for printing and include simulation convergence data, surface-integrated forcing data, and a simulation report file. The optional input commands and output file formats are described in this section.

@subsection Convergence Statistics Output

If the @samp{@option{print convergence}} command is present in the @file{simulation.config} file, various convergence statistics for the performed simulation will be output with convergence values provided at each @option{increment}. This @file{post.conv} file is tabulated with the given structure:

@inputfilehead
@example
@var{incr} @var{iter} @var{nr} @var{r_norm} @var{rx_norm} @var{f_norm} @var{delu_norm} @var{delux_norm} @var{u_norm} @var{cg_iter}
@end example
@inputfilefoot

where @code{@var{incr}} is the total increment value being printed, @code{@var{iter}} is a sub-increment iteration, @code{@var{nr}} is a boolean that notifies if the given @var{iter} was a Newton-Raphson iteration, @code{@var{r_norm}} is a residual norm, @code{@var{rx_norm}} is the maximum absolute value of @var{r_norm}, @code{@var{f_norm}} is a force norm, @code{@var{delu_norm}} is the change in velocity norm, @code{@var{delux_norm}} is the maximum absolute value of @var{delu_norm}, @code{@var{u_norm}} is the velocity norm, and @code{@var{cg_iter}} is the number of iterations the conjugate gradient solver performed. All norms are computed as @math{l^{2}}-norms or the square root of the inner product of a vector by itself.

@subsection Surface Forces Output

If the @samp{@option{print forces}} command is present in the @file{simulation.config} file, loads for all surfaces in the performed simulation will be output with load values provided at each @option{increment}. The @file{post.force.*} file names are constructed via the defined @option{faset_label} strings in the @file{simulation.msh} file. The default @option{faset_label} order is @samp{x0, x1, y0, y1, z0, z1} which defines the six orthogonal and planar surfaces that bound a domain. For example, @samp{x0} refers to the face where the nodal coordinate component values in the @dfn{x}-direction are minimum and the file @file{post.force.x0} would contain the surface-integrated forces on this face. These files are generally tabulated with the given structure:

@inputfilehead
@example
@var{step} @var{incr} @var{force_x} @var{force_y} @var{force_z} @var{surf_area} @var{current_time}
@end example
@inputfilefoot

where @code{@var{step}} is the prescribed load step, @code{@var{incr}} is the total increment value being printed, @code{@var{force_x}} is the surface-integrated force in the @var{x}-direction, @code{@var{force_y}} is the surface-integrated force in the @var{y}-direction, @code{@var{force_z}} is the surface-integrated force in the @var{z}-direction, @code{@var{surf_area}} is the current surface area of the given face in [area], and @code{@var{current_time}} is the total simulated time at the time of printing.

If multiaxial loading is utilized, an additional @code{@var{length}} column will be appended to the right of @code{@var{current_time}}. The @code{@var{length}} column contains the maximal coordinate values of the domain and these values are stored in their associated face files. For example, the maximal mesh coordinate value in the @dfn{x}-direction is stored in the @file{post.force.x0} and @file{post.force.x1} files accordingly.

@subsection Simulation Report File

The @file{post.report} file is always printed for a simulation. The report file is for utilization with Neper and contains the following information:

@inputfilehead
@example
@option{number_of_nodes} @var{value}
@option{number_of_elements} @var{value}
@option{number_of_partitions} @var{value}
@option{number_of_elements_byparition} @var{part1_num_elems} ... @var{partN_num_elems}
@option{number_of_nodes_byparition} @var{part1_num_nodes} ... @var{partN_num_nodes}
@option{number_of_slip_systems} @var{num_slip_systems_for_crystal_type}
@option{orientation_definition} @var{orientation_descriptor}:@var{orientation_convention}
@option{results_nodes} @var{nodal_output_files}
@option{results_elements} @var{elemental_output_files}
@option{number_of_steps} @var{number_of_completed_steps}
@end example
@inputfilefoot

@c DEBUG: Do we need a where here? I feel like this is self explanatory enough, but we can add one.

@node Fiber Averaging Output
@section Fiber Averaging Output

The optional fiber averaging routine (@pxref{The Fiber Averaging File (Optional)}) has the ability to gather the average and standard deviation of certain simulation output variables for elements which belong to the user-defined crystallographic fibers. Currently, the output available from the fiber averaging routine is (note that all output is printed by default if fiber averaging is activated):

@ftable @asis
@item @file{post.fib.crss} : Critical Resolved Shear Stress

In this file, the fiber averaged critical resolved shear stress is printed. For either an isotropic or anisotropic hardening assumption, the output file is structured as follows:

@verbatimsep
@verbatim
step_number num_fibers
crss1_fib1_avg crss2_fib1_avg ... crss1_fib1_std crss2_fib1_std ...
crss1_fib2_avg crss2_fib2_avg ... crss1_fib2_std crss2_fib2_std ...
...
@end verbatim
@verbatimsep

where @code{@var{crss*_fib*_avg}} refers to the average critical resolved shear stress over all of the elements that belong to that specific crystallographic fiber on a given slip system, and @code{@var{crss*_fib*_std}} refers to the standard deviation of the critical resolved shear stress over all of the elements that belong to that specific crystallographic fiber on a given slip system. One set of values is printed per fiber, one fiber per line. Each block is printed per @samp{step}. If a multiphase material is fiber-averaged, the number of @code{@var{fib*}} columns printed for a given fiber is determined by the maximal number of slip systems for the considered material phase. As such, the number of columns in this file may not necessarily be fixed throughout.

For body centered cubic crystal symmetry, values are printed in the order:

@math{ (0 1 \bar 1)[1 1 1],\,(1 0 \bar 1)[1 1 1],\,(1 \bar 1 0)[1 1 1],\,(0 1 1)[1 1 \bar 1],\,(1 0 1)[1 1 \bar 1],\,(1 \bar 1 0)[1 1 \bar 1],}
@math{ (0 1 1)[1 \bar 1 1],\,(1 0 \bar 1)[1 \bar 1 1],\,(1 1 0)[1 \bar 1 1],\,(0 1 \bar 1)[1 \bar 1 \bar 1],\,(1 0 1)[1 \bar 1 \bar 1],\,(1 1 0)[1 \bar 1 \bar 1] }.

For face centered cubic crystal symmetry, values are printed in the order:

@math{ (1 1 1)[0 1 \bar 1],\,(1 1 1)[1 0 \bar 1],\,(1 1 1)[1 \bar 1 0],\,(1 1 \bar 1)[0 1 1],\,(1 1 \bar 1)[1 0 1],\,(1 1 \bar 1)[1 \bar 1 0],\,}
@math{ (1 \bar 1 1)[0 1 1],\,(1 \bar 1 1)[1 0 \bar 1],\,(1 \bar 1 1)[1 1 0],\,(1 \bar 1 \bar 1)[0 1 \bar 1],\,(1 \bar 1 \bar 1)[1 0 1],\,(1 \bar 1 \bar 1)[1 1 0] }.

For hexagonal close packed crystal symmetry, values are printed in the order (corresponding to the 3 basal, 3 prismatic, and 12 pyramidal slip systems):

@math{ (0 0 0 1)[2 \bar 1 \bar 1 0],\,(0 0 0 1)[\bar 1 2 \bar 1 0],\,(0 0 0 1)[\bar 1 \bar 1 2 0],\,(0 1 \bar 1 0)[2 \bar 1 \bar 1 0],\,(\bar 1 0 1 0)[\bar 1 2 \bar 1 0],\,(1 \bar 1 0 0)[\bar 1 \bar 1 2 0],\,}
@math{ (1 0 \bar 1 1)[\bar 2 1 1 3],\,(1 0 \bar 1 1)[\bar 1 \bar 1 2 3],\,(0 1 \bar 1 1)[\bar 1 \bar 1 2 3],\,(0 1 \bar 1 1)[1 \bar 2 1 3],\,(\bar 1 1 0 1)[1 \bar 2 1 3],\,(\bar 1 1 0 1)[2 \bar 1 \bar 1 3],\,}
@math{ (\bar 1 0 1 1)[2 \bar 1 \bar 1 3],\,(\bar 1 0 1 1)[1 1 \bar 2 3],\,(0 \bar 1 1 1)[1 1 \bar 2 3],\,(0 \bar 1 1 1)[\bar 1 2 \bar 1 3],\,(1 \bar 1 0 1)[\bar 1 2 \bar 1 3],\,(1 \bar 1 0 1)[\bar 2 1 1 3] }.

For body centered tetragonal crystal symmetry, values are printed in the order:

@math{(1 0 0)[0 0 1],\,(0 1 0)[0 0 1],\,(1 1 0)[0 0 1],\,(1 \bar 1 0)[0 0 1],\,(1 0 0)[0 1 0],\,(0 1 0)[1 0 0]}
@math{(1 1 0)[1 \bar 1 1],\,(1 1 0)[\bar 1 1 1],\,(1 \bar 1 0)[1 1 1],\,(1 \bar 1 0)[\bar 1 \bar 1 1],\,(1 1 0)[\bar 1 1 0],\,(1 \bar 1 0)[1 1 0]}
@math{(1 0 0)[0 1 1],\,(1 0 0)[0 1 \bar 1],\,(0 1 0)[1 0 1],\,(0 1 0)[1 0 \bar 1],\,(0 0 1)[1 1 0],\,(0 0 1)[1 \bar 1 0]}
@math{(0 0 1)[1 1 0],\,(0 0 1)[1 \bar 1 0],\,(1 0 1)[1 0 \bar 1],\,(1 0 \bar 1)[1 0 1],\,(0 1 1)[0 1 \bar 1],\,(0 1 \bar 1)[0 1 1]}
@math{(1 2 1)[\bar 1 0 1],\,(\bar 1 2 1)[1 0 1],\,(\bar 1 \bar 2 1)[1 0 1],\,(1 \bar 2 1)[\bar 1 0 1],\,(2 1 1)[0 \bar 1 1],\,(\bar 2 1 1)[0 \bar 1 1]}
@math{(\bar 2 \bar 1 1)[0 1 1],\,(2 \bar 1 1)[0 1 1]}


@item @file{post.fib.defrate-pl-eq}:  Equivalent Plastic Deformation Rate

In this file, the fiber averaged equivalent plastic deformation rate is printed. The output file is structured as follows:

@verbatimsep
@verbatim
step_number num_fibers
defrate-pl-eq_fib1_avg defrate-pl-eq_fib1_std
defrate-pl-eq_fib2_avg defrate-pl-eq_fib2_std
...
@end verbatim
@verbatimsep

where @code{@var{defrate-pl-eq_fib*_avg}} refers to the average equivalent plastic deformation rate over all of the elements that belong to that specific crystallographic fiber, and @code{@var{defrate-pl-eq_fib*_std}} refers to the standard deviation of the equivalent plastic deformation rate over all of the elements that belong to that specific crystallographic fiber. One set of values is printed per fiber, one fiber per line. Each block is printed per @samp{step}.

@item @file{post.fib.sliprate-sum}: Sum of the Slip System Shear Rates

In this file, the fiber averaged sum of the slip system shear rates rate is printed. The output file is structured as follows:

@verbatimsep
@verbatim
step_number num_fibers
sliprate-sum_fib1_avg sliprate-sum_fib1_std
sliprate-sum_fib2_avg sliprate-sum_fib2_std
...
@end verbatim
@verbatimsep

where @code{@var{sliprate-sum_fib*_avg}} refers to the average sum of the slip system shear rates over all of the elements that belong to that specific crystallographic fiber, and @code{@var{sliprate-sum_fib*_std}} refers to the standard deviation of the sum of the slip system shear rates over all of the elements that belong to that specific crystallographic fiber. One set of values is printed per fiber, one fiber per line. Each block is printed per @samp{step}.

@item @file{post.fib.strain-el-lat}: Elastic Lattice Strains

In this file, the fiber averaged elastic lattice strain is printed. The output file is structured as follows:

@verbatimsep
@verbatim
step_number num_fibers
strain-el-lat_fib1_avg strain-el-lat_fib1_std
strain-el-lat_fib2_avg strain-el-lat_fib2_std
...
@end verbatim
@verbatimsep

where @code{@var{strain-el-lat_fib*_avg}} refers to the average elastic lattice strain over all of the elements that belong to that specific crystallographic fiber, and @code{@var{strain-el-lat_fib*_std}} refers to the standard deviation of the elastic lattice strain over all of the elements that belong to that specific crystallographic fiber. One set of values is printed per fiber, one fiber per line. Each block is printed per @samp{step}.

@item @file{post.fib.elt-stats}: Element Statistics

In this file, the element statistics for each fiber are printed. The output file is structured as follows:

@verbatimsep
@verbatim
step_number num_fibers
num_elt_fib1 vol_elt_fib1
num_elt_fib2 vol_elt_fib2
...
@end verbatim
@verbatimsep

where @code{@var{num_elt_fib*}} refers to the number of elements that belong to that specific crystallographic fiber, and @code{@var{vol_elt_fib*}} refers to the total volume of all of the elements that belong to that specific crystallographic fiber. One set of values is printed per fiber, one fiber per line. Each block is printed per @samp{step}.

@item @file{post.fib.elt.core*}: Lists of Elements Belonging to Crystallographic Fibers

In this file, the list of local elements (that is, elements on a particular core) belonging to each crystallographic fiber are printed. The output file is structured as follows:

@verbatimsep
@verbatim
step_number fib_id num_fib_elts core_start_elt core_end_elt
elt_id_1
elt_id_2
...
@end verbatim
@verbatimsep

where @code{@var{fib_id}} refers to the current fiber whose elements are being printed, @code{@var{num_fib_elts}} refers to the number of elements on the local core that meet the diffraction conditions, and @code{@var{elt_id_*}} refer to 1-indexed element IDs of elements that belong to the current fiber. One list of values is printed per fiber, @code{@var{num_fiber}} lists are printed per block. Each block is printed per @samp{step}.

@end ftable
@c end of output.texi
