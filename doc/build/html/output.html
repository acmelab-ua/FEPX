

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Simulation Output &mdash; FEPX 1.2.1 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
        <script type="text/javascript" src="_static/language_data.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Running a Simulation" href="job.html" />
    <link rel="prev" title="Simulation Input" href="input.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> FEPX
          

          
          </a>

          
            
            
              <div class="version">
                1.2.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="copying.html">Conditions of Use</a></li>
<li class="toctree-l1"><a class="reference internal" href="introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="input.html">Simulation Input</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Simulation Output</a></li>
<li class="toctree-l1"><a class="reference internal" href="job.html">Running a Simulation</a></li>
<li class="toctree-l1"><a class="reference internal" href="examples.html">Example Simulations</a></li>
<li class="toctree-l1"><a class="reference internal" href="develhistory.html">Development History</a></li>
<li class="toctree-l1"><a class="reference internal" href="refs.html">References</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">FEPX</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>Simulation Output</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/output.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <div class="rst-breadcrumbs-buttons" role="navigation" aria-label="breadcrumb navigation">
      
        <a href="job.html" class="btn btn-neutral float-right" title="Running a Simulation" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="input.html" class="btn btn-neutral float-left" title="Simulation Input" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
  </div>
  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="simulation-output">
<span id="id1"></span><h1>Simulation Output<a class="headerlink" href="#simulation-output" title="Permalink to this headline">¶</a></h1>
<p>In this section the output files are described. In general, the output can be broken down into five types: nodal output (variables that are calculated and printed at the finite element nodes), elemental output (variables that are calculated and printed at the finite elements), restart output (which contains all variables necessary to restart a simulation at a specific load step), miscellaneous output (macroscopic forces and various simulation statistics), and fiber averaged output (fiber averaged values of certain variables and other statistics associated with the fiber average output option).</p>
<p>All desired output must be defined in the &#64;file{simulation.config} file (&#64;pxref{Printing Results} for a description of the print options). A (small) &#64;file{post.report} file is systematically printed, which contains information necessary for post-processing with Neper. All output described in this section is &#64;emph{raw} simulation output and can be post-processed into a more human-readable format with Neper’s &#64;samp{-S} module. Refer to the Neper reference manual, &#64;url{<a class="reference external" href="https://neper.info/docs/neper.pdf">https://neper.info/docs/neper.pdf</a>}, for a more complete description of the &#64;samp{-S} module.</p>
<p>&#64;section Nodal Output</p>
<p>Nodal output prints a single variable per finite element node. Raw output is printed on a per-core basis, and the general file name structure is &#64;file{post.variable.core#}, where &#64;samp{variable} is the variable being printed, and &#64;samp{#} denotes the ID of the core on which the data is being printed. In general, the file structure is:</p>
<p>&#64;inputfilehead
&#64;example
step_number core_start_dof core_end_dof
node n values
node n+1 values
node n+2 values
…
&#64;end example
&#64;inputfilefoot</p>
<p>Here, a header line prints for each deformation step, which details the deformation step number, the initial degree of freedom that prints from that core, and the final degree of freedom that prints from that core. Note that the number of &#64;dfn{nodes} per-core is one third of the number of degrees of freedoms per-core. For each load step, multiple values associated with a variable are printed per line. When multiple values are printed per line, values are space delimited.</p>
<p>Below, the specific nodal values available for printing are explained in detail.</p>
<p>&#64;ftable &#64;code
&#64;item &#64;file{post.coo.core*} : Coordinates</p>
<p>In this file, the coordinates are printed. Each nodal coordinate is described in the orthonormal Cartesian sample basis, and one coordinate is printed per line (3 values per line). The components of the coordinates are printed in the order:</p>
<p>&#64;var{x}, &#64;var{y}, &#64;var{z}</p>
<p>&#64;item &#64;file{post.disp.core*} : Displacements</p>
<p>In this file, the displacements are printed. Each nodal displacement is described in the orthonormal Cartesian sample basis, and one displacement is printed per line (3 values per line). The components of the displacements are printed in the order:</p>
<p>&#64;var{d}&#64;sub{&#64;var{x}}, &#64;var{d}&#64;sub{&#64;var{y}}, &#64;var{d}&#64;sub{&#64;var{z}}</p>
<p>&#64;item &#64;file{post.vel.core*} : Velocities</p>
<p>In this file, the velocities are printed. Each nodal velocity is described in the orthonormal Cartesian sample basis, and one velocity is printed per line (3 values per line). The components of the velocities are printed in the order:</p>
<p>&#64;var{v}&#64;sub{&#64;var{x}}, &#64;var{v}&#64;sub{&#64;var{y}}, &#64;var{v}&#64;sub{&#64;var{z}}</p>
<p>&#64;end ftable</p>
<p>&#64;section Elemental Output</p>
<p>Elemental output prints a single variable per finite element. Raw output is printed on a per-core basis, and the general file name structure is &#64;file{post.variable.core#}, where &#64;samp{variable} is the variable being printed, and &#64;samp{#} denotes the ID of the core on which the data is being printed. In general, the file structure is:</p>
<p>&#64;c typical_start
&#64;example</p>
<blockquote>
<div>step_number core_start_elt core_end_elt
element n value(s)
element n+1 value(s)
element n+2 value(s)
…
step_number core_start_elt core_end_elt
element n value(s)
element n+1 value(s)
element n+2 value(s)
…</div></blockquote>
<p>&#64;end example
&#64;c typical_end</p>
<p>Here, a header line prints for each deformation step, which details the deformation step number, the initial element that prints from that core, and the final element that prints from that core. For each load step, either a single value associated with a variable is printed per line (for variables that are printed singularly per element, such as scalars), or multiple values associated with a variable are printed per line (for variables that print multiple values per element, such as tensors). When multiple values are printed per line, values are space delimited.</p>
<p>FEPX calculates elemental quantities at each Gauss quadrature point within the element (15 total). However, only one value is printed – that associated with the quadrature point that falls at the element centroid.</p>
<p>&#64;sp 1
Below, the specific nodal values available for printing are explained in detail.</p>
<p>&#64;ftable &#64;asis
&#64;item &#64;file{post.crss.core*} : Critical Resolved Shear Stress</p>
<p>In this file, the critical resolved shear stress is printed. For the isotropic hardening assumption (&#64;pxref{Optional Input Parameters}), one value is printed per element. For anisotropic hardening assumptions, the critical resolved shear stress is printed for each slip system per element, one line of values per element.</p>
<p>For body centered cubic crystal symmetry, values are printed in the order:</p>
<p>&#64;math{ (0 1 bar 1)[1 1 1],,(1 0 bar 1)[1 1 1],,(1 bar 1 0)[1 1 1],,(0 1 1)[1 1 bar 1],,(1 0 1)[1 1 bar 1],,(1 bar 1 0)[1 1 bar 1],}
&#64;math{ (0 1 1)[1 bar 1 1],,(1 0 bar 1)[1 bar 1 1],,(1 1 0)[1 bar 1 1],,(0 1 bar 1)[1 bar 1 bar 1],,(1 0 1)[1 bar 1 bar 1],,(1 1 0)[1 bar 1 bar 1] }.</p>
<p>For face centered cubic crystal symmetry, values are printed in the order:</p>
<p>&#64;math{ (1 1 1)[0 1 bar 1],,(1 1 1)[1 0 bar 1],,(1 1 1)[1 bar 1 0],,(1 1 bar 1)[0 1 1],,(1 1 bar 1)[1 0 1],,(1 1 bar 1)[1 bar 1 0],,}
&#64;math{ (1 bar 1 1)[0 1 1],,(1 bar 1 1)[1 0 bar 1],,(1 bar 1 1)[1 1 0],,(1 bar 1 bar 1)[0 1 bar 1],,(1 bar 1 bar 1)[1 0 1],,(1 bar 1 bar 1)[1 1 0] }.</p>
<p>For hexagonal close packed crystal symmetry, values are printed in the order (corresponding to the 3 basal, 3 prismatic, and 12 pyramidal slip systems):</p>
<p>&#64;math{ (0 0 0 1)[2 bar 1 bar 1 0],,(0 0 0 1)[bar 1 2 bar 1 0],,(0 0 0 1)[bar 1 bar 1 2 0],,(0 1 bar 1 0)[2 bar 1 bar 1 0],,(bar 1 0 1 0)[bar 1 2 bar 1 0],,(1 bar 1 0 0)[bar 1 bar 1 2 0],,}
&#64;math{ (1 0 bar 1 1)[bar 2 1 1 3],,(1 0 bar 1 1)[bar 1 bar 1 2 3],,(0 1 bar 1 1)[bar 1 bar 1 2 3],,(0 1 bar 1 1)[1 bar 2 1 3],,(bar 1 1 0 1)[1 bar 2 1 3],,(bar 1 1 0 1)[2 bar 1 bar 1 3],,}
&#64;math{ (bar 1 0 1 1)[2 bar 1 bar 1 3],,(bar 1 0 1 1)[1 1 bar 2 3],,(0 bar 1 1 1)[1 1 bar 2 3],,(0 bar 1 1 1)[bar 1 2 bar 1 3],,(1 bar 1 0 1)[bar 1 2 bar 1 3],,(1 bar 1 0 1)[bar 2 1 1 3] }.</p>
<p>For body centered tetragonal crystal symmetry, values are printed in the order:</p>
<p>&#64;math{(1 0 0)[0 0 1],,(0 1 0)[0 0 1],,(1 1 0)[0 0 1],,(1 bar 1 0)[0 0 1],,(1 0 0)[0 1 0],,(0 1 0)[1 0 0]}
&#64;math{(1 1 0)[1 bar 1 1],,(1 1 0)[bar 1 1 1],,(1 bar 1 0)[1 1 1],,(1 bar 1 0)[bar 1 bar 1 1],,(1 1 0)[bar 1 1 0],,(1 bar 1 0)[1 1 0]}
&#64;math{(1 0 0)[0 1 1],,(1 0 0)[0 1 bar 1],,(0 1 0)[1 0 1],,(0 1 0)[1 0 bar 1],,(0 0 1)[1 1 0],,(0 0 1)[1 bar 1 0]}
&#64;math{(0 0 1)[1 1 0],,(0 0 1)[1 bar 1 0],,(1 0 1)[1 0 bar 1],,(1 0 bar 1)[1 0 1],,(0 1 1)[0 1 bar 1],,(0 1 bar 1)[0 1 1]}
&#64;math{(1 2 1)[bar 1 0 1],,(bar 1 2 1)[1 0 1],,(bar 1 bar 2 1)[1 0 1],,(1 bar 2 1)[bar 1 0 1],,(2 1 1)[0 bar 1 1],,(bar 2 1 1)[0 bar 1 1]}
&#64;math{(bar 2 bar 1 1)[0 1 1],,(2 bar 1 1)[0 1 1]}</p>
<p>&#64;item &#64;file{post.defrate.core*} : Deformation Rate Tensor</p>
<p>In this file, the deformation rate tensor is printed. Each tensor, &#64;math{bf D}, is printed in the sample basis. The independent components are printed, one tensor per line (6 values per line). The components, &#64;math{D _{ij}}, are printed in the order:</p>
<p>&#64;math{D_{11},,D_{22},,D_{33},,D_{23},,D_{13},,D_{12}}</p>
<p>&#64;item &#64;file{post.defrate-eq.core*} : Equivalent Deformation Rate</p>
<p>In this file, the equivalent deformation rate is printed. One scalar value is printed per element. The equivalent deformation rate, &#64;math{D}, is calculated based on the deformation rate tensor, &#64;math{{bf D}}, via the tensor inner product:</p>
<p>&#64;math{D = sqrt{ {2 over 3} {bf D} : {bf D} }}</p>
<p>&#64;item &#64;file{post.defrate-pl.core*} : Plastic Deformation Rate Tensor</p>
<p>In this file, the deviatoric plastic deformation rate tensor is printed. Each tensor, &#64;math{{bf D}^p}, is printed in the sample basis. The independent components are printed, one tensor per line (6 values per line). The components, &#64;math{D^p_{ij}}, are printed in the order:</p>
<p>&#64;math{D^p_{11},,D^p_{22},,D^p_{33},,D^p_{23},,D^p_{13},,D^p_{12}}</p>
<p>&#64;item &#64;file{post.defrate-pl-eq.core*} : Equivalent Plastic Deformation Rate</p>
<p>In this file, the equivalent plastic deformation rate is printed. One scalar value is printed per element. The equivalent plastic deformation rate, &#64;math{D^p}, is calculated based on the plastic deformation rate tensor, &#64;math{{bf D}^p}, via the tensor inner product:</p>
<p>&#64;math{D^p = sqrt{ {2 over 3} {bf D}^p : {bf D}^p }}</p>
<p>&#64;item &#64;file{post.elt-vol.core*} : Elemental Volume</p>
<p>In this file, the elemental volume is printed. One scalar value is printed per element. The elemental volume is calculated as the Gaussian integration of the determinant of the Jacobian matrix:</p>
<p>&#64;math{V_{el} = sum_{i=1}^{n_{qp}}{det(J_i) w_i }}</p>
<p>&#64;item &#64;file{post.ori.core*} : Crystallographic Orientation</p>
<p>In this file, the crystallographic orientation is printed. Depending on the orientation parameterization used as input, the orientation values may range from 3 values per element (when using Rodrigues vector, Euler-Bunge angles and Euler-Kocks angles parameterizations) or 4 values per element (when using axis-angle or quaternion parameterizations). One orientation is printed per line (3 or 4 values per line).</p>
<p>For Rodrigues: &#64;math{r_1,,r_2,,r_3}, where the Rodrigues vector is &#64;math{{bf r} = {bf t} tan{(omega / 2)}}.</p>
<p>For Euler-Bunge: &#64;math{phi_1,,theta,,phi_2} (where &#64;math{phi_1} is the rotation about the &#64;math{z} axis, &#64;math{theta} is the rotation about the &#64;math{x^{prime}} axis, and &#64;math{phi_2} is the rotation about the &#64;math{z^{prime prime}} axis, all in degrees).</p>
<p>For Euler-Kocks: &#64;math{Psi,,Theta,,phi} (where &#64;math{Psi} is the rotation about the &#64;math{z} axis, &#64;math{Theta} is the rotation about the &#64;math{y^{prime}} axis, and &#64;math{phi} is the rotation about the &#64;math{z^{prime prime}} axis, all in degrees).</p>
<p>For axis-angle: &#64;math{t_1,,t_2,,t_3,,omega} (where &#64;math{bf{t}} is the normalized axis of rotation and &#64;math{omega} is the angle of rotation about said axis, in degrees).</p>
<p>For quaternion: &#64;math{q_0,,q_1,,q_2,,q_3}, where &#64;math{q_0 = cos{(omega / 2)}} and &#64;math{q_i = t_i sin{(omega / 2)}} for &#64;math{i = 1,,2,,3}.</p>
<p>&#64;item &#64;file{post.slip.core*} : Slip System Shear</p>
<p>In this file, the accumulated slip system shear is printed. The slip system shear is printed for each slip system per element, one line of values per element.</p>
<p>For body centered cubic crystal symmetry, values are printed in the order:</p>
<p>&#64;math{ (0 1 bar 1)[1 1 1],,(1 0 bar 1)[1 1 1],,(1 bar 1 0)[1 1 1],,(0 1 1)[1 1 bar 1],,(1 0 1)[1 1 bar 1],,(1 bar 1 0)[1 1 bar 1],}
&#64;math{ (0 1 1)[1 bar 1 1],,(1 0 bar 1)[1 bar 1 1],,(1 1 0)[1 bar 1 1],,(0 1 bar 1)[1 bar 1 bar 1],,(1 0 1)[1 bar 1 bar 1],,(1 1 0)[1 bar 1 bar 1] }.</p>
<p>For face centered cubic crystal symmetry, values are printed in the order:</p>
<p>&#64;math{ (1 1 1)[0 1 bar 1],,(1 1 1)[1 0 bar 1],,(1 1 1)[1 bar 1 0],,(1 1 bar 1)[0 1 1],,(1 1 bar 1)[1 0 1],,(1 1 bar 1)[1 bar 1 0],,}
&#64;math{ (1 bar 1 1)[0 1 1],,(1 bar 1 1)[1 0 bar 1],,(1 bar 1 1)[1 1 0],,(1 bar 1 bar 1)[0 1 bar 1],,(1 bar 1 bar 1)[1 0 1],,(1 bar 1 bar 1)[1 1 0] }.</p>
<p>For hexagonal close packed crystal symmetry, values are printed in the order (corresponding to the 3 basal, 3 prismatic, and 12 pyramidal slip systems):</p>
<p>&#64;math{ (0 0 0 1)[2 bar 1 bar 1 0],,(0 0 0 1)[bar 1 2 bar 1 0],,(0 0 0 1)[bar 1 bar 1 2 0],,(0 1 bar 1 0)[2 bar 1 bar 1 0],,(bar 1 0 1 0)[bar 1 2 bar 1 0],,(1 bar 1 0 0)[bar 1 bar 1 2 0],,}
&#64;math{ (1 0 bar 1 1)[bar 2 1 1 3],,(1 0 bar 1 1)[bar 1 bar 1 2 3],,(0 1 bar 1 1)[bar 1 bar 1 2 3],,(0 1 bar 1 1)[1 bar 2 1 3],,(bar 1 1 0 1)[1 bar 2 1 3],,(bar 1 1 0 1)[2 bar 1 bar 1 3],,}
&#64;math{ (bar 1 0 1 1)[2 bar 1 bar 1 3],,(bar 1 0 1 1)[1 1 bar 2 3],,(0 bar 1 1 1)[1 1 bar 2 3],,(0 bar 1 1 1)[bar 1 2 bar 1 3],,(1 bar 1 0 1)[bar 1 2 bar 1 3],,(1 bar 1 0 1)[bar 2 1 1 3] }.</p>
<p>For body centered tetragonal crystal symmetry, values are printed in the order:</p>
<p>&#64;math{(1 0 0)[0 0 1],,(0 1 0)[0 0 1],,(1 1 0)[0 0 1],,(1 bar 1 0)[0 0 1],,(1 0 0)[0 1 0],,(0 1 0)[1 0 0]}
&#64;math{(1 1 0)[1 bar 1 1],,(1 1 0)[bar 1 1 1],,(1 bar 1 0)[1 1 1],,(1 bar 1 0)[bar 1 bar 1 1],,(1 1 0)[bar 1 1 0],,(1 bar 1 0)[1 1 0]}
&#64;math{(1 0 0)[0 1 1],,(1 0 0)[0 1 bar 1],,(0 1 0)[1 0 1],,(0 1 0)[1 0 bar 1],,(0 0 1)[1 1 0],,(0 0 1)[1 bar 1 0]}
&#64;math{(0 0 1)[1 1 0],,(0 0 1)[1 bar 1 0],,(1 0 1)[1 0 bar 1],,(1 0 bar 1)[1 0 1],,(0 1 1)[0 1 bar 1],,(0 1 bar 1)[0 1 1]}
&#64;math{(1 2 1)[bar 1 0 1],,(bar 1 2 1)[1 0 1],,(bar 1 bar 2 1)[1 0 1],,(1 bar 2 1)[bar 1 0 1],,(2 1 1)[0 bar 1 1],,(bar 2 1 1)[0 bar 1 1]}
&#64;math{(bar 2 bar 1 1)[0 1 1],,(2 bar 1 1)[0 1 1]}</p>
<p>&#64;item &#64;file{post.sliprate.core*} : Slip System Shear Rate</p>
<p>In this file, the slip system shear rate is printed. The slip system shear rate is printed for each slip system per element, one line of values per element.</p>
<p>For body centered cubic crystal symmetry, values are printed in the order:</p>
<p>&#64;math{ (0 1 bar 1)[1 1 1],,(1 0 bar 1)[1 1 1],,(1 bar 1 0)[1 1 1],,(0 1 1)[1 1 bar 1],,(1 0 1)[1 1 bar 1],,(1 bar 1 0)[1 1 bar 1],}
&#64;math{ (0 1 1)[1 bar 1 1],,(1 0 bar 1)[1 bar 1 1],,(1 1 0)[1 bar 1 1],,(0 1 bar 1)[1 bar 1 bar 1],,(1 0 1)[1 bar 1 bar 1],,(1 1 0)[1 bar 1 bar 1] }.</p>
<p>For face centered cubic crystal symmetry, values are printed in the order:</p>
<p>&#64;math{ (1 1 1)[0 1 bar 1],,(1 1 1)[1 0 bar 1],,(1 1 1)[1 bar 1 0],,(1 1 bar 1)[0 1 1],,(1 1 bar 1)[1 0 1],,(1 1 bar 1)[1 bar 1 0],,}
&#64;math{ (1 bar 1 1)[0 1 1],,(1 bar 1 1)[1 0 bar 1],,(1 bar 1 1)[1 1 0],,(1 bar 1 bar 1)[0 1 bar 1],,(1 bar 1 bar 1)[1 0 1],,(1 bar 1 bar 1)[1 1 0] }.</p>
<p>For hexagonal close packed crystal symmetry, values are printed in the order (corresponding to the 3 basal, 3 prismatic, and 12 pyramidal slip systems):</p>
<p>&#64;math{ (0 0 0 1)[2 bar 1 bar 1 0],,(0 0 0 1)[bar 1 2 bar 1 0],,(0 0 0 1)[bar 1 bar 1 2 0],,(0 1 bar 1 0)[2 bar 1 bar 1 0],,(bar 1 0 1 0)[bar 1 2 bar 1 0],,(1 bar 1 0 0)[bar 1 bar 1 2 0],,}
&#64;math{ (1 0 bar 1 1)[bar 2 1 1 3],,(1 0 bar 1 1)[bar 1 bar 1 2 3],,(0 1 bar 1 1)[bar 1 bar 1 2 3],,(0 1 bar 1 1)[1 bar 2 1 3],,(bar 1 1 0 1)[1 bar 2 1 3],,(bar 1 1 0 1)[2 bar 1 bar 1 3],,}
&#64;math{ (bar 1 0 1 1)[2 bar 1 bar 1 3],,(bar 1 0 1 1)[1 1 bar 2 3],,(0 bar 1 1 1)[1 1 bar 2 3],,(0 bar 1 1 1)[bar 1 2 bar 1 3],,(1 bar 1 0 1)[bar 1 2 bar 1 3],,(1 bar 1 0 1)[bar 2 1 1 3] }.</p>
<p>For body centered tetragonal crystal symmetry, values are printed in the order:</p>
<p>&#64;math{(1 0 0)[0 0 1],,(0 1 0)[0 0 1],,(1 1 0)[0 0 1],,(1 bar 1 0)[0 0 1],,(1 0 0)[0 1 0],,(0 1 0)[1 0 0]}
&#64;math{(1 1 0)[1 bar 1 1],,(1 1 0)[bar 1 1 1],,(1 bar 1 0)[1 1 1],,(1 bar 1 0)[bar 1 bar 1 1],,(1 1 0)[bar 1 1 0],,(1 bar 1 0)[1 1 0]}
&#64;math{(1 0 0)[0 1 1],,(1 0 0)[0 1 bar 1],,(0 1 0)[1 0 1],,(0 1 0)[1 0 bar 1],,(0 0 1)[1 1 0],,(0 0 1)[1 bar 1 0]}
&#64;math{(0 0 1)[1 1 0],,(0 0 1)[1 bar 1 0],,(1 0 1)[1 0 bar 1],,(1 0 bar 1)[1 0 1],,(0 1 1)[0 1 bar 1],,(0 1 bar 1)[0 1 1]}
&#64;math{(1 2 1)[bar 1 0 1],,(bar 1 2 1)[1 0 1],,(bar 1 bar 2 1)[1 0 1],,(1 bar 2 1)[bar 1 0 1],,(2 1 1)[0 bar 1 1],,(bar 2 1 1)[0 bar 1 1]}
&#64;math{(bar 2 bar 1 1)[0 1 1],,(2 bar 1 1)[0 1 1]}</p>
<p>&#64;item &#64;file{post.spinrate.core*} : Plastic Spin Rate Tensor</p>
<p>In this file, the skew-symmetric plastic spin rate tensor is printed. Each tensor, &#64;math{{bf W}^p}, is printed in the sample basis. The independent components are printed, one tensor per line (3 values per line). The components, &#64;math{W^p_{ij}}, are printed in the order:</p>
<p>&#64;math{ W^p_{12},&#64; W^p_{13},&#64; W^p_{23} }</p>
<p>&#64;item &#64;file{post.strain.core*} : Total Strain Tensor</p>
<p>In this file, the total strain tensor is printed. Each tensor, &#64;math{bf E}, is printed in the sample basis. The independent components are printed, one tensor per line (6 values per line). The components, &#64;math{E_{ij}}, are printed in the order:</p>
<p>&#64;math{ E_{11},&#64; E_{22},&#64; E_{33},&#64; E_{23},&#64; E_{13},&#64; E_{12}}</p>
<p>&#64;item &#64;file{post.strain-eq.core*} : Equivalent Total Strain</p>
<p>In this file, the equivalent total strain is printed. One scalar value is printed per element. The equivalent total strain, &#64;math{E}, is calculated based on the deviatoric portion of the total strain tensor, &#64;math{{bf E}^prime}. via the tensor inner product:</p>
<p>&#64;math{E = sqrt{ {2 over 3} {bf E}^prime : {bf E}^prime}}</p>
<p>&#64;item &#64;file{post.strain-el.core*} : Elastic Strain Tensor</p>
<p>In this file, the elastic strain tensor is printed. Each tensor, &#64;math{bf {E}^e}, is printed in the sample basis. The independent components are printed, one tensor per line (6 values per line). The components, &#64;math{E^e_{ij}}, are printed in the order:</p>
<p>&#64;math{ E^e_{11},&#64; E^e_{22},&#64; E^e_{33},&#64; E^e_{23},&#64; E^e_{13},&#64; E^e_{12}}</p>
<p>&#64;item &#64;file{post.strain-el-eq.core*} : Equivalent Elastic Strain</p>
<p>In this file, the equivalent elastic strain is printed. One scalar value is printed per element. The equivalent elastic strain, &#64;math{E^{e}}, is calculated based on the deviatoric portion of the elastic strain tensor, &#64;math{{bf E}^{e prime}}, via the tensor inner product:</p>
<p>&#64;math{E^e = sqrt{ {2 over 3} {bf E}^{e prime} : {bf E}^{e prime}}}</p>
<p>&#64;item &#64;file{post.strain-pl.core*} : Plastic Strain Tensor</p>
<p>In this file, the plastic strain tensor is printed. Each tensor, &#64;math{bf {E}^p}, is printed in the sample basis. The independent components are printed, one tensor per line (6 values per line). The components, &#64;math{E^p_{ij}}, are printed in the order:</p>
<p>&#64;math{ E^p_{11},&#64; E^p_{22},&#64; E^p_{33},&#64; E^p_{23},&#64; E^p_{13},&#64; E^p_{12}}</p>
<p>&#64;item &#64;file{post.strain-pl-eq.core*} : Equivalent Plastic Strain</p>
<p>In this file, the equivalent plastic strain is printed. One scalar value is printed per element. The equivalent plastic strain, &#64;math{E^p}, is calculated based on the plastic strain tensor, &#64;math{{bf E}^p}, via the tensor inner product:</p>
<p>&#64;math{E^p = sqrt{ {2 over 3} {bf E}^p : {bf E}^p }}</p>
<p>&#64;item &#64;file{post.stress.core*} : Stress Tensor</p>
<p>In this file, the symmetric stress tensor is printed. Each tensor, &#64;math{bf sigma}, is printed in the sample basis. The independent components are printed, one tensor per line (6 values per line). The components, &#64;math{sigma_{ij}}, are printed in the order:</p>
<p>&#64;math{ sigma_{11},&#64; sigma_{22},&#64; sigma_{33},&#64; sigma_{23},&#64; sigma_{13},&#64; sigma_{12}}</p>
<p>&#64;item &#64;file{post.stress-eq.core*} : Equivalent Stress</p>
<p>In this file, the equivalent stress is printed. One scalar value is printed per element. The equivalent stress, &#64;math{sigma}, is calculated based on the deviatoric portion of the stress tensor, &#64;math{{bf sigma}^{prime}}, via the tensor inner product:</p>
<p>&#64;math{sigma = sqrt{ {3 over 2} {bf sigma}^{prime} : {bf sigma}^{prime}}}</p>
<p>&#64;item &#64;file{post.velgrad.core*} : Velocity Gradient Tensor</p>
<p>In this file, the velocity gradient tensor is printed. Each tensor, &#64;math{bf L}, is printed in the sample basis. One tensor is printed per line (9 values per line). The components, &#64;math{L_{ij}},  are printed in the order:</p>
<p>&#64;math{ L_{11},&#64; L_{12},&#64; L_{13},&#64; L_{21},&#64; L_{22},&#64; L_{23},&#64; L_{31},&#64; L_{32},&#64; L_{33} }</p>
<p>&#64;item &#64;file{post.work.core*} : Work</p>
<p>In this file, the work is printed. One scalar value is printed per element. The work is calculated as the time integration of the tensor inner product of the deformation rate tensor and the Cauchy stress tensor:</p>
<p>&#64;math{W = int{  (sigma : {bf D}) }Delta t}</p>
<p>&#64;item &#64;file{post.work-pl.core*} : Plastic Work</p>
<p>In this file, the plastic work is printed. One scalar value is printed per element. The plastic work is calculated as the time integration of the tensor inner product of the plastic deformation rate tensor and the deviatoric portion of the Cauchy stress tensor:</p>
<p>&#64;math{ W^p = int{ ( sigma ^ prime :  {bf D }^ p ) Delta t} }</p>
<p>&#64;item &#64;file{post.workrate.core*} : Work Rate</p>
<p>In this file, the work rate is printed. One scalar value is printed per element. The work rate is calculated as the tensor inner product of the deformation rate tensor and the Cauchy stress tensor:</p>
<p>&#64;math{dot{W} = sigma : {bf D} }</p>
<p>&#64;item &#64;file{post.workrate-pl.core*} : Plastic Work Rate</p>
<p>In this file, the plastic work rate is printed. One scalar value is printed per element. The plastic work rate is calculated as the tensor inner product of the plastic deformation rate tensor and the deviatoric portion of the Cauchy stress tensor:</p>
<p>&#64;math{dot{W}^p = sigma ^ prime : {bf D }^ p }</p>
<p>&#64;end ftable</p>
<p>&#64;node Restart Output
&#64;section Restart Output</p>
<p>If the &#64;samp{&#64;option{print restart}} command is present in the
&#64;file{simulation.config} file, a set of additional restart files will be
generated from the simulation. These files are written at the end of each
prescribed step and contain necessary information to restart a given simulation
(&#64;pxref{Restarting a Simulation} for information on how to restart a
simulation). Two types of restart files are generated, a control file,
&#64;samp{<a class="reference external" href="mailto:rst&#37;&#52;&#48;var{N}&#46;control">rst<span>&#64;</span>var{N}<span>&#46;</span>control</a>}, and per-core field files,
&#64;samp{<a class="reference external" href="mailto:rst&#37;&#52;&#48;var{N}&#46;field&#46;core*">rst<span>&#64;</span>var{N}<span>&#46;</span>field<span>&#46;</span>core*</a>} (where &#64;samp{&#64;var{N}} indicates which
simulation the files describe, 0 indexing). Both file types are unformatted
(or binary) files and are generally unmodifiable. The structures of the data
stored within both files for the various deformation modes follow.</p>
<p>&#64;subsection Uniaxial Restart Control</p>
<p>The &#64;file{<a class="reference external" href="mailto:rst&#37;&#52;&#48;var{N}&#46;control">rst<span>&#64;</span>var{N}<span>&#46;</span>control</a>} file for uniaxial loading modes contains
the following data in the given order:</p>
<p>&#64;inputfilehead
&#64;example
&#64;option{current_step} &#64;var{integer}
&#64;option{previous_load_array} &#64;var{real_x} &#64;var{real_y} &#64;var{real_z}
&#64;option{step_complete_flag} &#64;var{logical}
&#64;option{previous_timestep_value} &#64;var{real}
&#64;option{current_incr} &#64;var{integer}
&#64;option{current_time} &#64;var{real}
&#64;option{surface_1_loads} &#64;var{real_x} &#64;var{real_y} &#64;var{real_z}
…
&#64;option{surface_6_loads} &#64;var{real_x} &#64;var{real_y} &#64;var{real_z}
&#64;option{previous_prescribed_load} &#64;var{real}
&#64;option{current_surface_areas} &#64;var{real_surf_1} … &#64;var{real_surf_6}
&#64;option{initial_surface_areas} &#64;var{real_surf_1} … &#64;var{real_surf_6}
&#64;end example
&#64;inputfilefoot</p>
<p>&#64;subsection Multiaxial CSR Restart Control</p>
<p>The &#64;file{<a class="reference external" href="mailto:rst&#37;&#52;&#48;var{N}&#46;control">rst<span>&#64;</span>var{N}<span>&#46;</span>control</a>} file for multiaxial constant strain rate
loading modes contains the following data in the given order:</p>
<p>&#64;inputfilehead
&#64;example
&#64;option{current_step} &#64;var{integer}
&#64;option{current_load_array} &#64;var{real_x} &#64;var{real_y} &#64;var{real_z}
&#64;option{previous_load_array} &#64;var{real_x} &#64;var{real_y} &#64;var{real_z}
&#64;option{step_complete_flag} &#64;var{logical}
&#64;option{previous_timestep_value} &#64;var{real}
&#64;option{current_incr} &#64;var{integer}
&#64;option{current_time} &#64;var{real}
&#64;option{surface_1_loads} &#64;var{real_x} &#64;var{real_y} &#64;var{real_z}
…
&#64;option{surface_6_loads} &#64;var{real_x} &#64;var{real_y} &#64;var{real_z}
&#64;option{current_surface_areas} &#64;var{real_surf_1} … &#64;var{real_surf_6}
&#64;option{initial_surface_areas} &#64;var{real_surf_1} … &#64;var{real_surf_6}
&#64;option{current_mesh_lengths} &#64;var{real_length_x} &#64;var{real_length_y} &#64;var{real_length_z}
&#64;option{initial_mesh_lengths} &#64;var{real_length_x} &#64;var{real_length_y} &#64;var{real_length_z}
&#64;option{current_control_velocity} &#64;var{real_vel_x} &#64;var{real_vel_y} &#64;var{real_vel_z}
&#64;option{s_pert_mag} &#64;var{real}
&#64;option{t_pert_mag} &#64;var{real}
&#64;end example
&#64;inputfilefoot</p>
<p>&#64;subsection Multiaxial CLR Restart Control</p>
<p>The &#64;file{<a class="reference external" href="mailto:rst&#37;&#52;&#48;var{N}&#46;control">rst<span>&#64;</span>var{N}<span>&#46;</span>control</a>} file for multiaxial constant load rate
loading modes contains the following data in the given order:</p>
<p>&#64;inputfilehead
&#64;example
&#64;option{current_step} &#64;var{integer}
&#64;option{current_load_array} &#64;var{real_x} &#64;var{real_y} &#64;var{real_z}
&#64;option{previous_load_array} &#64;var{real_x} &#64;var{real_y} &#64;var{real_z}
&#64;option{first_incr_in_step} &#64;var{logical}
&#64;option{current_incr} &#64;var{integer}
&#64;option{current_time} &#64;var{real}
&#64;option{surface_1_loads} &#64;var{real_x} &#64;var{real_y} &#64;var{real_z}
…
&#64;option{surface_6_loads} &#64;var{real_x} &#64;var{real_y} &#64;var{real_z}
&#64;option{current_surface_areas} &#64;var{real_surf_1} … &#64;var{real_surf_6}
&#64;option{initial_surface_areas} &#64;var{real_surf_1} … &#64;var{real_surf_6}
&#64;option{current_mesh_lengths} &#64;var{real_length_x} &#64;var{real_length_y} &#64;var{real_length_z}
&#64;option{initial_mesh_lengths} &#64;var{real_length_x} &#64;var{real_length_y} &#64;var{real_length_z}
&#64;option{current_control_velocity} &#64;var{real_vel_x} &#64;var{real_vel_y} &#64;var{real_vel_z}
&#64;option{previous_control_action} &#64;var{integer}
&#64;option{current_control_action} &#64;var{integer}
&#64;option{initial_load_dwell_velocity} &#64;var{real_vel_x} &#64;var{real_vel_y} &#64;var{real_vel_z}
&#64;option{initial_unload_dwell_velocity} &#64;var{real_vel_x} &#64;var{real_vel_y} &#64;var{real_vel_z}
&#64;end example
&#64;inputfilefoot</p>
<p>&#64;subsection Restart Field Data</p>
<p>All loading modes also write field data on a per-core basis to
&#64;file{<a class="reference external" href="mailto:rst&#37;&#52;&#48;var{N}&#46;field&#46;core*">rst<span>&#64;</span>var{N}<span>&#46;</span>field<span>&#46;</span>core*</a>} files. These files contain the necessary
field variable information in order to spatially define the total state of the
virtual sample at the time of printing. The following field data arrays are
written to the files in the given order:</p>
<p>&#64;inputfilehead
&#64;example
&#64;option{coords} &#64;var{real}
&#64;option{velocity} &#64;var{real}</p>
<p>&#64;option{c0_angs} &#64;var{real}
&#64;option{c_angs} &#64;var{real}
&#64;option{rstar} &#64;var{real}
&#64;option{rstar_n} &#64;var{real}
&#64;option{wts} &#64;var{real}
&#64;option{crss} &#64;var{real}
&#64;option{crss_n} &#64;var{real}</p>
<p>&#64;option{gela_kk_bar} &#64;var{real}
&#64;option{gsig_vec_n} &#64;var{real}
&#64;option{pela_kk_bar} &#64;var{real}
&#64;option{psig_vec_n} &#64;var{real}
&#64;option{e_elas_kk_bar} &#64;var{real}
&#64;option{sig_vec_n} &#64;var{real}</p>
<p>&#64;option{eqstrain} &#64;var{real}
&#64;option{eqplstrain} &#64;var{real}
&#64;option{gamma} &#64;var{real}</p>
<p>&#64;option{el_work_n} &#64;var{real}
&#64;option{el_workp_n} &#64;var{real}
&#64;option{el_work_rate_n} &#64;var{real}
&#64;option{el_workp_rate_n} &#64;var{real}
&#64;end example
&#64;inputfilefoot</p>
<p>&#64;node Miscellaneous Output
&#64;section Miscellaneous Output</p>
<p>In addition to nodal and elemental variable printing, miscellaneous output is available for printing and include simulation convergence data, surface-integrated forcing data, and a simulation report file. The optional input commands and output file formats are described in this section.</p>
<p>&#64;subsection Convergence Statistics Output</p>
<p>If the &#64;samp{&#64;option{print convergence}} command is present in the &#64;file{simulation.config} file, various convergence statistics for the performed simulation will be output with convergence values provided at each &#64;option{increment}. This &#64;file{post.conv} file is tabulated with the given structure:</p>
<p>&#64;inputfilehead
&#64;example
&#64;var{incr} &#64;var{iter} &#64;var{nr} &#64;var{r_norm} &#64;var{rx_norm} &#64;var{f_norm} &#64;var{delu_norm} &#64;var{delux_norm} &#64;var{u_norm} &#64;var{cg_iter}
&#64;end example
&#64;inputfilefoot</p>
<p>where &#64;code{&#64;var{incr}} is the total increment value being printed, &#64;code{&#64;var{iter}} is a sub-increment iteration, &#64;code{&#64;var{nr}} is a boolean that notifies if the given &#64;var{iter} was a Newton-Raphson iteration, &#64;code{&#64;var{r_norm}} is a residual norm, &#64;code{&#64;var{rx_norm}} is the maximum absolute value of &#64;var{r_norm}, &#64;code{&#64;var{f_norm}} is a force norm, &#64;code{&#64;var{delu_norm}} is the change in velocity norm, &#64;code{&#64;var{delux_norm}} is the maximum absolute value of &#64;var{delu_norm}, &#64;code{&#64;var{u_norm}} is the velocity norm, and &#64;code{&#64;var{cg_iter}} is the number of iterations the conjugate gradient solver performed. All norms are computed as &#64;math{l^{2}}-norms or the square root of the inner product of a vector by itself.</p>
<p>&#64;subsection Surface Forces Output</p>
<p>If the &#64;samp{&#64;option{print forces}} command is present in the &#64;file{simulation.config} file, loads for all surfaces in the performed simulation will be output with load values provided at each &#64;option{increment}. The &#64;file{post.force.*} file names are constructed via the defined &#64;option{faset_label} strings in the &#64;file{simulation.msh} file. The default &#64;option{faset_label} order is &#64;samp{x0, x1, y0, y1, z0, z1} which defines the six orthogonal and planar surfaces that bound a domain. For example, &#64;samp{x0} refers to the face where the nodal coordinate component values in the &#64;dfn{x}-direction are minimum and the file &#64;file{post.force.x0} would contain the surface-integrated forces on this face. These files are generally tabulated with the given structure:</p>
<p>&#64;inputfilehead
&#64;example
&#64;var{step} &#64;var{incr} &#64;var{force_x} &#64;var{force_y} &#64;var{force_z} &#64;var{surf_area} &#64;var{current_time}
&#64;end example
&#64;inputfilefoot</p>
<p>where &#64;code{&#64;var{step}} is the prescribed load step, &#64;code{&#64;var{incr}} is the total increment value being printed, &#64;code{&#64;var{force_x}} is the surface-integrated force in the &#64;var{x}-direction, &#64;code{&#64;var{force_y}} is the surface-integrated force in the &#64;var{y}-direction, &#64;code{&#64;var{force_z}} is the surface-integrated force in the &#64;var{z}-direction, &#64;code{&#64;var{surf_area}} is the current surface area of the given face in [area], and &#64;code{&#64;var{current_time}} is the total simulated time at the time of printing.</p>
<p>If multiaxial loading is utilized, an additional &#64;code{&#64;var{length}} column will be appended to the right of &#64;code{&#64;var{current_time}}. The &#64;code{&#64;var{length}} column contains the maximal coordinate values of the domain and these values are stored in their associated face files. For example, the maximal mesh coordinate value in the &#64;dfn{x}-direction is stored in the &#64;file{post.force.x0} and &#64;file{post.force.x1} files accordingly.</p>
<p>&#64;subsection Simulation Report File</p>
<p>The &#64;file{post.report} file is always printed for a simulation. The report file is for utilization with Neper and contains the following information:</p>
<p>&#64;inputfilehead
&#64;example
&#64;option{number_of_nodes} &#64;var{value}
&#64;option{number_of_elements} &#64;var{value}
&#64;option{number_of_partitions} &#64;var{value}
&#64;option{number_of_elements_byparition} &#64;var{part1_num_elems} … &#64;var{partN_num_elems}
&#64;option{number_of_nodes_byparition} &#64;var{part1_num_nodes} … &#64;var{partN_num_nodes}
&#64;option{number_of_slip_systems} &#64;var{num_slip_systems_for_crystal_type}
&#64;option{orientation_definition} &#64;var{orientation_descriptor}:&#64;var{orientation_convention}
&#64;option{results_nodes} &#64;var{nodal_output_files}
&#64;option{results_elements} &#64;var{elemental_output_files}
&#64;option{number_of_steps} &#64;var{number_of_completed_steps}
&#64;end example
&#64;inputfilefoot</p>
<p>&#64;c DEBUG: Do we need a where here? I feel like this is self explanatory enough, but we can add one.</p>
<p>&#64;node Fiber Averaging Output
&#64;section Fiber Averaging Output</p>
<p>The optional fiber averaging routine (&#64;pxref{The Fiber Averaging File (Optional)}) has the ability to gather the average and standard deviation of certain simulation output variables for elements which belong to the user-defined crystallographic fibers. Currently, the output available from the fiber averaging routine is (note that all output is printed by default if fiber averaging is activated):</p>
<p>&#64;ftable &#64;asis
&#64;item &#64;file{post.fib.crss} : Critical Resolved Shear Stress</p>
<p>In this file, the fiber averaged critical resolved shear stress is printed. For either an isotropic or anisotropic hardening assumption, the output file is structured as follows:</p>
<p>&#64;verbatimsep
&#64;verbatim
step_number num_fibers
crss1_fib1_avg crss2_fib1_avg … crss1_fib1_std crss2_fib1_std …
crss1_fib2_avg crss2_fib2_avg … crss1_fib2_std crss2_fib2_std …
…
&#64;end verbatim
&#64;verbatimsep</p>
<p>where &#64;code{&#64;var{crss*_fib*_avg}} refers to the average critical resolved shear stress over all of the elements that belong to that specific crystallographic fiber on a given slip system, and &#64;code{&#64;var{crss*_fib*_std}} refers to the standard deviation of the critical resolved shear stress over all of the elements that belong to that specific crystallographic fiber on a given slip system. One set of values is printed per fiber, one fiber per line. Each block is printed per &#64;samp{step}. If a multiphase material is fiber-averaged, the number of &#64;code{&#64;var{fib*}} columns printed for a given fiber is determined by the maximal number of slip systems for the considered material phase. As such, the number of columns in this file may not necessarily be fixed throughout.</p>
<p>For body centered cubic crystal symmetry, values are printed in the order:</p>
<p>&#64;math{ (0 1 bar 1)[1 1 1],,(1 0 bar 1)[1 1 1],,(1 bar 1 0)[1 1 1],,(0 1 1)[1 1 bar 1],,(1 0 1)[1 1 bar 1],,(1 bar 1 0)[1 1 bar 1],}
&#64;math{ (0 1 1)[1 bar 1 1],,(1 0 bar 1)[1 bar 1 1],,(1 1 0)[1 bar 1 1],,(0 1 bar 1)[1 bar 1 bar 1],,(1 0 1)[1 bar 1 bar 1],,(1 1 0)[1 bar 1 bar 1] }.</p>
<p>For face centered cubic crystal symmetry, values are printed in the order:</p>
<p>&#64;math{ (1 1 1)[0 1 bar 1],,(1 1 1)[1 0 bar 1],,(1 1 1)[1 bar 1 0],,(1 1 bar 1)[0 1 1],,(1 1 bar 1)[1 0 1],,(1 1 bar 1)[1 bar 1 0],,}
&#64;math{ (1 bar 1 1)[0 1 1],,(1 bar 1 1)[1 0 bar 1],,(1 bar 1 1)[1 1 0],,(1 bar 1 bar 1)[0 1 bar 1],,(1 bar 1 bar 1)[1 0 1],,(1 bar 1 bar 1)[1 1 0] }.</p>
<p>For hexagonal close packed crystal symmetry, values are printed in the order (corresponding to the 3 basal, 3 prismatic, and 12 pyramidal slip systems):</p>
<p>&#64;math{ (0 0 0 1)[2 bar 1 bar 1 0],,(0 0 0 1)[bar 1 2 bar 1 0],,(0 0 0 1)[bar 1 bar 1 2 0],,(0 1 bar 1 0)[2 bar 1 bar 1 0],,(bar 1 0 1 0)[bar 1 2 bar 1 0],,(1 bar 1 0 0)[bar 1 bar 1 2 0],,}
&#64;math{ (1 0 bar 1 1)[bar 2 1 1 3],,(1 0 bar 1 1)[bar 1 bar 1 2 3],,(0 1 bar 1 1)[bar 1 bar 1 2 3],,(0 1 bar 1 1)[1 bar 2 1 3],,(bar 1 1 0 1)[1 bar 2 1 3],,(bar 1 1 0 1)[2 bar 1 bar 1 3],,}
&#64;math{ (bar 1 0 1 1)[2 bar 1 bar 1 3],,(bar 1 0 1 1)[1 1 bar 2 3],,(0 bar 1 1 1)[1 1 bar 2 3],,(0 bar 1 1 1)[bar 1 2 bar 1 3],,(1 bar 1 0 1)[bar 1 2 bar 1 3],,(1 bar 1 0 1)[bar 2 1 1 3] }.</p>
<p>For body centered tetragonal crystal symmetry, values are printed in the order:</p>
<p>&#64;math{(1 0 0)[0 0 1],,(0 1 0)[0 0 1],,(1 1 0)[0 0 1],,(1 bar 1 0)[0 0 1],,(1 0 0)[0 1 0],,(0 1 0)[1 0 0]}
&#64;math{(1 1 0)[1 bar 1 1],,(1 1 0)[bar 1 1 1],,(1 bar 1 0)[1 1 1],,(1 bar 1 0)[bar 1 bar 1 1],,(1 1 0)[bar 1 1 0],,(1 bar 1 0)[1 1 0]}
&#64;math{(1 0 0)[0 1 1],,(1 0 0)[0 1 bar 1],,(0 1 0)[1 0 1],,(0 1 0)[1 0 bar 1],,(0 0 1)[1 1 0],,(0 0 1)[1 bar 1 0]}
&#64;math{(0 0 1)[1 1 0],,(0 0 1)[1 bar 1 0],,(1 0 1)[1 0 bar 1],,(1 0 bar 1)[1 0 1],,(0 1 1)[0 1 bar 1],,(0 1 bar 1)[0 1 1]}
&#64;math{(1 2 1)[bar 1 0 1],,(bar 1 2 1)[1 0 1],,(bar 1 bar 2 1)[1 0 1],,(1 bar 2 1)[bar 1 0 1],,(2 1 1)[0 bar 1 1],,(bar 2 1 1)[0 bar 1 1]}
&#64;math{(bar 2 bar 1 1)[0 1 1],,(2 bar 1 1)[0 1 1]}</p>
<p>&#64;item &#64;file{post.fib.defrate-pl-eq}:  Equivalent Plastic Deformation Rate</p>
<p>In this file, the fiber averaged equivalent plastic deformation rate is printed. The output file is structured as follows:</p>
<p>&#64;verbatimsep
&#64;verbatim
step_number num_fibers
defrate-pl-eq_fib1_avg defrate-pl-eq_fib1_std
defrate-pl-eq_fib2_avg defrate-pl-eq_fib2_std
…
&#64;end verbatim
&#64;verbatimsep</p>
<p>where &#64;code{&#64;var{defrate-pl-eq_fib*_avg}} refers to the average equivalent plastic deformation rate over all of the elements that belong to that specific crystallographic fiber, and &#64;code{&#64;var{defrate-pl-eq_fib*_std}} refers to the standard deviation of the equivalent plastic deformation rate over all of the elements that belong to that specific crystallographic fiber. One set of values is printed per fiber, one fiber per line. Each block is printed per &#64;samp{step}.</p>
<p>&#64;item &#64;file{post.fib.sliprate-sum}: Sum of the Slip System Shear Rates</p>
<p>In this file, the fiber averaged sum of the slip system shear rates rate is printed. The output file is structured as follows:</p>
<p>&#64;verbatimsep
&#64;verbatim
step_number num_fibers
sliprate-sum_fib1_avg sliprate-sum_fib1_std
sliprate-sum_fib2_avg sliprate-sum_fib2_std
…
&#64;end verbatim
&#64;verbatimsep</p>
<p>where &#64;code{&#64;var{sliprate-sum_fib*_avg}} refers to the average sum of the slip system shear rates over all of the elements that belong to that specific crystallographic fiber, and &#64;code{&#64;var{sliprate-sum_fib*_std}} refers to the standard deviation of the sum of the slip system shear rates over all of the elements that belong to that specific crystallographic fiber. One set of values is printed per fiber, one fiber per line. Each block is printed per &#64;samp{step}.</p>
<p>&#64;item &#64;file{post.fib.strain-el-lat}: Elastic Lattice Strains</p>
<p>In this file, the fiber averaged elastic lattice strain is printed. The output file is structured as follows:</p>
<p>&#64;verbatimsep
&#64;verbatim
step_number num_fibers
strain-el-lat_fib1_avg strain-el-lat_fib1_std
strain-el-lat_fib2_avg strain-el-lat_fib2_std
…
&#64;end verbatim
&#64;verbatimsep</p>
<p>where &#64;code{&#64;var{strain-el-lat_fib*_avg}} refers to the average elastic lattice strain over all of the elements that belong to that specific crystallographic fiber, and &#64;code{&#64;var{strain-el-lat_fib*_std}} refers to the standard deviation of the elastic lattice strain over all of the elements that belong to that specific crystallographic fiber. One set of values is printed per fiber, one fiber per line. Each block is printed per &#64;samp{step}.</p>
<p>&#64;item &#64;file{post.fib.elt-stats}: Element Statistics</p>
<p>In this file, the element statistics for each fiber are printed. The output file is structured as follows:</p>
<p>&#64;verbatimsep
&#64;verbatim
step_number num_fibers
num_elt_fib1 vol_elt_fib1
num_elt_fib2 vol_elt_fib2
…
&#64;end verbatim
&#64;verbatimsep</p>
<p>where &#64;code{&#64;var{num_elt_fib*}} refers to the number of elements that belong to that specific crystallographic fiber, and &#64;code{&#64;var{vol_elt_fib*}} refers to the total volume of all of the elements that belong to that specific crystallographic fiber. One set of values is printed per fiber, one fiber per line. Each block is printed per &#64;samp{step}.</p>
<p>&#64;item &#64;file{post.fib.elt.core*}: Lists of Elements Belonging to Crystallographic Fibers</p>
<p>In this file, the list of local elements (that is, elements on a particular core) belonging to each crystallographic fiber are printed. The output file is structured as follows:</p>
<p>&#64;verbatimsep
&#64;verbatim
step_number fib_id num_fib_elts core_start_elt core_end_elt
elt_id_1
elt_id_2
…
&#64;end verbatim
&#64;verbatimsep</p>
<p>where &#64;code{&#64;var{fib_id}} refers to the current fiber whose elements are being printed, &#64;code{&#64;var{num_fib_elts}} refers to the number of elements on the local core that meet the diffraction conditions, and &#64;code{&#64;var{elt_id_*}} refer to 1-indexed element IDs of elements that belong to the current fiber. One list of values is printed per fiber, &#64;code{&#64;var{num_fiber}} lists are printed per block. Each block is printed per &#64;samp{step}.</p>
<p>&#64;end ftable
&#64;c end of output.texi</p>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="job.html" class="btn btn-neutral float-right" title="Running a Simulation" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="input.html" class="btn btn-neutral float-left" title="Simulation Input" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>